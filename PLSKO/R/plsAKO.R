#' Pipleline For Integration Multiple PLSKO with Aggregate Knockoffs (AKO) Procedure
#'
#' This function implements the Aggregate Knockoffs (AKO) procedure from Nguyen et al. (2020)  with knockoff variables generated by PLSKO, to address the randomness from single-run knockoffs and improve the stablity. It generates multiple knockoff copies from PLSKO, computes feature importance statistics, aggregates p-values across knockoff realisations to control the false discovery rate. Compared to single-run knockoffs, AKO improved the average power with FDR control. The function is adapted from Tian et al. (2022).
#'
#' @import knockoff
#' @import foreach
#' @import doParallel
#' @import parallel
#' @import progress
#'
#' @param X A numeric matrix or dataframe. The original predictor data matrix with \eqn{n} observations as rows and \eqn{p} variables as columns.
#' @param y A numeric vector of responses.
#' @param n_ko An integer specifying the number of knockoff copies to generate by PLSKO. Default is 25.
#' @param q A numeric value specifying the target false discovery rate (FDR). Default is 0.05.
#' @param offset An integer (0 or 1) specifying the offset in the empirical p-value calculation. Default is \eqn{0} (liberally control modified FDR with higher power). Other options include \eqn{1}, similar to "knockoffs+", yielding a slightly more conservative procedure that controls the FDR according to the usual definition.
#' @param w.method A character string specifying the method to compute feature importance statistics. Default is \code{"lasso.lcd"}. Other options include \code{"lasso.logistic"} for binary response variable, \code{"lasso.max.lambda"} for the maximum lambda value for the first entry on the path, and \code{"RF"} for random forest. See \code{\link{ko_filter}} or \code{\link{knockoff::knockoff.filter}} for more details.
#' @param gamma A numeric value between 0 and 1 for the quantile aggregation parameter. Default is 0.3.
#' @param parallel Logical value indicating whether to run the process in parallel. Default is \code{TRUE}.
#' @param ncores An integer specifying the number of cores to use for parallel processing. Default is NULL, which uses all available cores except one.
#' @param seed An integer to set the random seed for reproducibility. Default is 1.
#' @param ... Additional arguments passed to the \link[=plsko]{plsko} knockoff-generating function.
#'
#' @return A list of class 'AKO.result', containing:
#' \describe{
#'   \item{`s`}{A list of results from individual knockoff filters.}
#'   \item{`ako.s`}{The named vector of selected variables after aggregating knockoff results.}
#'   \item{`threshold`}{The FDR control threshold from AKO.}
#' }
#'
#' @examples
#'
#' # Example usage of ko.filter
#' set.seed(1)
#' X <- matrix(rnorm(100*10), 100, 10)
#' colnames(X) <- paste0("X", 1:10)
#'
#' # Example 1: continuous response without parallelisation
#' # randomly assign zero or one as coefficients to the variables
#' beta <- sample(c(0, 1), 10, replace = TRUE)
#' y <- X %*% beta + rnorm(100)
#'
#' # run the knockoff filter
#' start.time <- Sys.time()
#' result <- plsAKO(X, y, q = 0.1, n_ko = 15, parallel = FALSE)
#' end.time <- Sys.time()
#' time.taken <- end.time - start.time
#' print(result)
#' time.taken
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result$s, function(x) x$selected)))
#'
#' # compare with the true coefficients
#' which(beta != 0)
#'
#' # Example 2: continuous response with parallelisation
#'
#' start.time <- Sys.time()
#' result <- plsAKO(X, y, q = 0.1, n_ko = 15, parallel = T, ncores = 4)
#' end.time <- Sys.time()
#' time.taken <- end.time - start.time
#' print(result)
#' time.taken
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result$s, function(x) x$selected)))
#'
#' # compare with the true coefficients
#' which(beta != 0)
#'
#' # Example 3: binary response
#' y.bin <- rbinom(100, 1, 1/(1+ exp(-(X %*% beta)))) # convert to binary response
#' result.bin <- plsAKO(X, y.bin, n_ko = 15, q = 0.1, w.method = "lasso.logistic", parallel = T, ncores = 4)
#' print(result.bin)
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result.bin$s, function(x) x$selected)))
#'
#' @references Yang G et al. PLSKO: a robust knockoff generator to control false discovery rate in omics variable selection. 2024:2024.08.06.606935.
#' @references Nguyen T-B et al. Aggregation of Multiple Knockoffs. Proceedings of the 37th International Conference on Machine Learning. PMLR, 2020, 7283–93.

#' @references Tian P et al. Grace-AKO: a novel and stable knockoff filter for variable selection incorporating gene network structures. BMC Bioinformatics 2022;23:478.

#'
#' @export
#'
plsAKO <- function(X, y, n_ko = 25,
                q = 0.05, offset = 0, w.method = "lasso.lcd",
                gamma = 0.3, parallel = T, ncores = NULL, seed = 1, ...){

  #Input type validation
  if(is.data.frame(X)){
    X.name = names(X)
    X = as.matrix(X)
  }else if (is.matrix(X)) {
    X.names = colnames(X)
  }else {
    stop('Input X must be a numeric matrix or data frame')
  }
  if (!is.numeric(X)) stop('Input X must be a numeric matrix or data frame')

  if (!is.factor(y) && !is.numeric(y)) {
    stop('Input y must be either of numeric or factor type')
  }
  if( is.numeric(y) ) y = as.vector(y)

  if(offset!=1 && offset!=0) {
    stop('Input offset must be either 0 or 1')
  }

  if (!w.method %in% c("lasso.lcd", "lasso.logistic", "lasso.max.lambda", "RF")) stop('Input w.method must be either "lasso.lcd", "lasso.logistic", "lasso.max.lambda" or "RF". Or check function "AKO_withW" for advanced customised W input')

  # Check if the number of observations in X is equal to the length of y
  stopifnot(length(y) == nrow(X))

  set.seed(seed)

  if(parallel){
    if (!requireNamespace('doParallel', quietly=T)) {
      warning('doParallel is not installed. Without parallelisation, the multiple knockoff sets will be slower to generate', call.=F,immediate.=T)
      parallel=F
    }
    if (!requireNamespace('foreach', quietly=T)) {
      warning('foreach is not installed. Without parallelisation, the multiple knockoff sets will be slower to generate', call.=F,immediate.=T)
      parallel=F
    }

    # Register cores for parallel computation
    if (parallel) {
      all_cores = parallel::detectCores(all.tests = TRUE, logical = TRUE)-1
      if(is.null(ncores)) ncores = all_cores # if not specified, use all cores except one
      if (ncores > ncores ) {
          warning(paste("The requested number of cores is not available. Using instead",all_cores,"cores"),immediate.=T)
          ncores = all_cores
      }
      if (ncores>1) {
        doParallel::registerDoParallel(cores=ncores)
        parallel = TRUE
      }
      else {
        parallel = FALSE
      }
    }

    if(parallel){
    para.result <- foreach::foreach(i = 1:n_ko, .packages = 'knockoff') %dopar% {
          set.seed(seed + i)
          # Generate PLSKO knockoff
          ko = plsko(X, ...)

          # Calculate the apply knokcoff filter
          S <- ko_filter(X = X, Xk = ko, y = y, q = q, w.method = w.method, cores = 1)

          pvals = empirical_pval(S$statistic, offset = offset)

          res <- list(pvals = pvals, S = S)
          return(res)
    }
    doParallel::stopImplicitCluster()
    pvals = do.call(cbind, lapply(para.result, function(x) x$pvals))
    selected = lapply(para.result, function(x) x$S)
  }
 } else {
   # Initialize matrix to store p-values from each knockoff iteration
   pvals = matrix(0, ncol(X), n_ko)
   selected <- list()

   # Initialize the progress bar
   pb <- progress_bar$new(
     format = " Running multiple knockoffs [:bar] :percent in :elapsed",
     total = n_ko, clear = FALSE, width = 60
   )

    for (i in 1:n_ko) {
      set.seed(seed + i)
      # Generate PLSKO knockoff
      ko = plsko(X, ...)

      # Calculate the apply knokcoff filter
      S <- ko_filter(X = X, Xk = ko, y = y, q = q, w.method = w.method)

      pvals[,i] = empirical_pval(S$statistic, offset = offset)
      selected[[i]] <- S

      # Update the progress bar
      pb$tick()
    }
  }

  aggregated_pval = apply(pvals, 1, quantile_aggregation, gamma=gamma)

  threshold = bhq_threshold(aggregated_pval, fdr=q)

  ako.s <- which(aggregated_pval <= threshold)
  names(ako.s) = X.names[ako.s]

  result <- structure(list(call = match.call(),
                           s = selected,
                          ako.s = ako.s,
                          threshold = threshold),
                      class = 'AKO.result')
  return(result)
}

#' Aggregated Knockoff (AKO) with Generated Knockoff Sets
#'
#' Performs Aggregated Knockoff analysis with multiple knockoff sets to improve the stability of results. The function is adapted from Tian et al. (2022).
#'
#' @param X A \eqn{n \times p} numeric matrix or data frame of predictors.
#' @param y A numeric or factor response vector of length \eqn{n}.
#' @param Xko.list A list of knockoff variable matrices (\eqn{n \times p}) corresponding to the original matrix \code{X}.
#' @param q A numeric value of the target false discovery rate (FDR) level. Default is \eqn{0.05}.
#' @param w.method A string specifying the method to compute test statistics. Options are \code{"lasso.lcd"}, \code{"lasso.logistic"}, \code{"lasso.max.lambda"}, \code{"RF"}. Default is \code{"lasso.lcd"}.
#' @param offset An integer (0 or 1) specifying the offset in the empirical p-value calculation. Default is \eqn{0} (liberally control modified FDR with higher power). Other options include \eqn{1}, similar to "knockoffs+", yielding a slightly more conservative procedure that controls the FDR according to the usual definition.
#' @param gamma A numeric value for quantile aggregation in the multiple knockoff p-value aggregation. Default is \eqn{0.3}.
#' @param parallel Logical value indicating whether to run the process in parallel. Default is \code{TRUE}.
#' @param ncores An integer specifying the number of cores to use for parallel processing. Default is NULL, which uses all available cores except one.
#' @param seed A numeric value for the random seed. Default is \eqn{1}.
#'
#' @return A list of class 'AKO.result', containing:
#' \describe{
#'   \item{`s`}{A list of results from individual knockoff filters.}
#'   \item{`ako.s`}{The named vector of selected variables after aggregating knockoff results.}
#'   \item{`threshold`}{The FDR control threshold.}
#' }
#'
#' @examples
#' # Example
#' set.seed(1)
#' X <- matrix(rnorm(100*10), 100, 10)
#' colnames(X) <- paste0("X", 1:10)
#' # randomly assign zero or one as coefficients to the variables
#' beta <- sample(c(0, 1), 10, replace = TRUE)
#' y <- X %*% beta + rnorm(100)
#'
#' # Generate multiple knockoff sets (using the default knockoff generating function in \code{\link{knockoff::create.second_order}})
#' Xko.list <- lapply(1:15, function(i) knockoff::create.second_order(X))
#'
#' # run the AKO filter
#' result <- AKO_withKO(X, y, Xko.list, q = 0.1, ncore = 4)
#' print(result)
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result$s, function(x) x$selected)))
#'
#' # compare with the true coefficients
#' which(beta != 0)
#'
#' @references Nguyen T-B, Chevalier J-A, Thirion B et al. Aggregation of Multiple Knockoffs. Proceedings of the 37th International Conference on Machine Learning. PMLR, 2020, 7283–93.
#' @references Tian P, Hu Y, Liu Z et al. Grace-AKO: a novel and stable knockoff filter for variable selection incorporating gene network structures. BMC Bioinformatics 2022;23:478.
#' @export
#'
# AKO with generated knockoff sets as a list
AKO_withKO <- function(X, y, Xko.list,
                       q = 0.05,  w.method = "lasso.lcd", offset = 0,
                       gamma = 0.3, seed = 1, parallel = T, ncores = NULL){

  # Input type validation
  if(is.data.frame(X)){
    X.names = colnames(X)
    X = as.matrix(X)
  } else if (is.matrix(X)) {
    X.names = colnames(X)
  } else {
    stop('Input X must be a numeric matrix or data frame')
  }
  if (!is.numeric(X)) stop('Input X must be a numeric matrix or data frame')

  if (!is.factor(y) && !is.numeric(y)) {
    stop('Input y must be either of numeric or factor type')
  }
  if(is.numeric(y)) y = as.vector(y)

  if(offset != 1 && offset != 0) {
    stop('Input offset must be either 0 or 1')
  }

  if (!w.method %in% c("lasso.lcd", "lasso.logistic", "lasso.max.lambda", "RF")) stop('Input w.method must be either "lasso.lcd", "lasso.logistic", "lasso.max.lambda" or "RF".')

  # Check if the number of observations in X is equal to the length of y
  stopifnot(length(y) == nrow(X))

  set.seed(seed)

  n_ko = length(Xko.list)

  if(parallel){
    # Load required packages for parallelization
    if (!requireNamespace('doParallel', quietly=T)) {
      warning('doParallel is not installed. Running sequentially.', call.=F, immediate.=T)
      parallel = F
    }
    if (!requireNamespace('foreach', quietly=T)) {
      warning('foreach is not installed. Running sequentially.', call.=F, immediate.=T)
      parallel = F
    }

    if (parallel) {
      all_cores = parallel::detectCores(all.tests = TRUE, logical = TRUE) - 1
      if (is.null(ncores)) ncores = all_cores # if not specified, use all cores except one
      if (ncores > all_cores) {
        warning(paste("Requested more cores than available. Using", all_cores, "cores"), immediate.=T)
        ncores = all_cores
      }
      if (ncores > 1) {
        doParallel::registerDoParallel(cores = ncores)
        parallel = TRUE
      } else {
        parallel = FALSE
      }
    }
  }

  if (parallel) {
    # Parallel execution using foreach
    para.result <- foreach::foreach(i = 1:n_ko, .packages = 'knockoff') %dopar% {
      ko <- Xko.list[[i]]
      S <- ko_filter(X = X, Xk = ko, y = y, q = q, w.method = w.method)
      pvals = empirical_pval(S$statistic, offset = offset)
      return(list(pvals = pvals, S = S))
    }
    doParallel::stopImplicitCluster()

    # Combine results
    pvals = do.call(cbind, lapply(para.result, function(x) x$pvals))
    selected = lapply(para.result, function(x) x$S)
  } else {
    # Sequential execution
    pvals = matrix(0, ncol(X), n_ko)
    selected <- list()
    for (i in 1:n_ko) {
      ko <- Xko.list[[i]]
      S <- ko_filter(X = X, Xk = ko, y = y, q = q, w.method = w.method)
      pvals[,i] = empirical_pval(S$statistic, offset = offset)
      selected[[i]] <- S
    }
  }

  # Aggregation of p-values
  aggregated_pval = apply(pvals, 1, quantile_aggregation, gamma=gamma)
  threshold = bhq_threshold(aggregated_pval, fdr=q)
  ako.s <- which(aggregated_pval <= threshold)
  names(ako.s) = X.names[ako.s]

  result <- structure(list(call = match.call(),
                           selected = selected,
                           ako.selected = ako.s,
                           threshold = threshold),
                      class = 'AKO.result')
  return(result)
}

#' Aggregated Knockoff with Precomputed Test Statistics \eqn{W} From User-Defined Methods
#'
#' Performs Aggregated Knockoff analysis using precomputed test statistics `W`.
#'
#' @param W A list of test statistics from multiple knockoff filters. The length of the list should be the number of knockoff copies. Each element in the list should be a numeric vector of length \eqn{p} representing the test statistics.
#' @param q A numeric value of the target false discovery rate (FDR) level. Default is \eqn{0.05}.
#' @param offset An integer (0 or 1) specifying the offset in the empirical p-value calculation. Default is \eqn{0} (liberally control modified FDR with higher power). Other options include \eqn{1}, similar to "knockoffs+", yielding a slightly more conservative procedure that controls the FDR according to the usual definition.
#' @param gamma A numeric value for quantile aggregation in the multiple knockoff p-value aggregation. Default is \eqn{0.3}.
#'
#' @return A list containing:
#' \describe{
#'   \item{`s`}{A list of results from individual knockoff filters.}
#'   \item{`ako.s`}{The set of selected variables after aggregating knockoff results.}
#'   \item{`threshold`}{The FDR control threshold.}
#' }
#'
#' @examples
#' # Example usage of AKO_withW
#' X <- matrix(rnorm(100*10), 100, 10)
#' # randomly assign zero or one as coefficients to the variables
#' beta <- sample(c(0, 1), 10, replace = TRUE)
#' y <- X %*% beta + rnorm(100)
#'
#' # Generate multiple knockoff sets using PLSKO
#' n_ko = 15
#' Xko.list <- lapply(1:n_ko, function(i) plsko(X))
#'
#' # Generate test statistics for each knockoff set using the difference of coefficients from an OLS linear regression
#' W <- lapply(Xko.list, function(Xko) {
#'  X_new <- cbind(X, Xko)
#'  beta <- coef(lm(y ~ X_new - 1)) # run orgianal variables and knockoff variables together into an OLS regression without intercept
#'  abs(beta[1:ncol(X)]) - abs(beta[(ncol(X)+1):ncol(X_new)]) # difference of coefficients
#'  })
#'
#' # run the AKO filter
#' result <- AKO_withW(W, q = 0.1)
#' print(result)
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result$s, function(x) x$selected)))
#'
#' # compare with the true coefficients
#' which(beta != 0)
#'
#'
#' @export
AKO_withW <- function(W, q = 0.05, offset = 0, gamma = 0.3){

  p = length(W[[1]])
  n_ko = length(W)

  pvals = matrix(0, p, n_ko)
  selected <- list()
  #Multiple Knockoffs
  for (i in 1:n_ko) {
    pvals[,i] = empirical_pval(W[[i]], offset = offset)
    S <- ko_withW(W[[i]], q = q)
    selected[[i]] <- S
  }

  aggregated_pval = apply(pvals, 1, quantile_aggregation, gamma=gamma)

  threshold = bhq_threshold(aggregated_pval, fdr=q)

  ako.s <- which(aggregated_pval <= threshold)

  if(!is.null(names(ako.s))){
    names(ako.s) = names(W[[1]])[ako.s]
  }

  result <- structure(list(call = match.call(),
                           s = selected,
                           ako.s = ako.s,
                           threshold = threshold),
                      class = 'AKO.result')
  return(result)
}

#' Print AKO Result
#'
#' Prints the results of the Aggregated Knockoff (AKO) filter, including the call and selected variables.
#'
#' @param x An object of class `'AKO.result'`, which contains the results from running the AKO procedure.
#' @param ... Additional arguments (currently unused).
#'
#' @return None. The function prints the call and the set of selected variables.
#'
#' @examples
#' # Example usage of print.AKO.result
#' print(result)
#'
#' @seealso \code{\link{plsAKO}}, \code{\link{AKO_withKO}}, \code{\link{AKO_withW}}
#'
#' @export
print.AKO.result <- function(x, ...) {
  cat('Call:\n')
  print(x$call)

  cat('\nSelected variables (AKO):\n')
  print(x$ako.s)
}


#' Compute Empirical P-values from Test Statistics
#'
#' Computes empirical p-values from test statistics. Function Adapted from P Tian et al. (2022).
#'
#' @param test_score A numeric vector of test statistics.
#' @param offset A numeric value to adjust p-values. Options are `0` or `1`. Default is `1`.
#'
#' @return A numeric vector of empirical p-values.
#'
#' @references Tian P, Hu Y, Liu Z et al. Grace-AKO: a novel and stable knockoff filter for variable selection incorporating gene network structures. BMC Bioinformatics 2022;23:478.
#' @keywords internal
empirical_pval = function(test_score, offset = 1){
  pvals = c()
  n_features = length(test_score)
  if (offset !=0 && offset!=1){
    return("'offset' must be either 0 or 1")
  }
  else{
    test_score_inv = -test_score
    for (i in 1:n_features){
      if (test_score[i] <= 0){
        pvals = c(pvals, 1)
      }
      else{
        pvals = c(pvals,(offset+sum(test_score_inv[i] >= test_score))/n_features)
      }
    }
  }
  return (pvals)
}

#' Quantile Aggregation
#'
#' Aggregates multiple p-values using quantile aggregation based on Meinshausen et al. (2009). Function Adapted from P Tian et al. (2022).
#'
#' @param pvals A numeric vector of p-values.
#' @param gamma A numeric value for the quantile to use in aggregation. Default is `0.3`.
#'
#' @return A numeric value representing the aggregated p-value.
#' @references Meinshausen N, Meier L, Bühlmann P. p-Values for High-Dimensional Regression. Journal of the American Statistical Association 2009;104:1671–81.
#' @references Tian P, Hu Y, Liu Z et al. Grace-AKO: a novel and stable knockoff filter for variable selection incorporating gene network structures. BMC Bioinformatics 2022;23:478.
#' @keywords internal

quantile_aggregation = function(pvals, gamma=0.3){
  converted_score = (1 / gamma) *  quantile(pvals, gamma)
  return (min(1, converted_score))
}

#' BHQ Threshold for FDR Control
#'
#' Computes the Benjamini-Hochberg (BH) threshold for FDR control. Function Adapted from P Tian et al. (2022).
#'
#' @param pvals A numeric vector of p-values.
#' @param fdr A numeric value specifying the false discovery rate level. Default is `0.1`.
#'
#' @return A numeric value representing the threshold for FDR control.
#'
#' @references Tian P, Hu Y, Liu Z et al. Grace-AKO: a novel and stable knockoff filter for variable selection incorporating gene network structures. BMC Bioinformatics 2022;23:478.
#' @keywords internal
bhq_threshold = function(pvals, fdr=0.1){
  n_features = length(pvals)
  pvals_sorted = sort(pvals)
  selected_index = 2 * n_features
  for (i in seq(n_features, 1, -1)){
    if (pvals_sorted[i] <= (fdr * i / n_features)){
      selected_index = i
      break
    }
  }
  if (selected_index <= n_features){
    return (pvals_sorted[selected_index])
  }
  else{
    return ('-1.0')
  }
}
